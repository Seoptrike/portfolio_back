<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.backend.mapper.StatsMapper">

    <!--
      공통 가정
      - page_events(ts timestamptz, user_id uuid, event_type text, is_internal bool ...)
      - 타임존: UTC 저장, 질의 시 KST로 변환
      - 내부 트래픽 제외: is_internal = true 행 제외 (없으면 조건 자동 생략)
    -->

    <!-- 오늘 DAU (회원 기준, KST) -->
    <select id="selectTodayDAU" parameterType="map" resultType="long">
        SELECT COUNT(DISTINCT pe.user_id) AS dau
        FROM page_events pe
        WHERE pe.user_id IS NOT NULL
        AND (timezone('Asia/Seoul', pe.ts))::date = CURRENT_DATE
        <if test="excludeInternal">
            AND EXISTS (
            SELECT 1 FROM users u
            WHERE u.user_id = pe.user_id
            AND u.role = 1             -- 일반회원만
            )
        </if>
    </select>

    <!-- 최근 30일 MAU -->
    <select id="selectMAULast30d" parameterType="map" resultType="long">
        SELECT COUNT(DISTINCT pe.user_id) AS mau
        FROM page_events pe
        WHERE pe.user_id IS NOT NULL
        AND (timezone('Asia/Seoul', pe.ts))::date
        BETWEEN (CURRENT_DATE - INTERVAL '29 days') AND CURRENT_DATE
        <if test="excludeInternal">
            AND EXISTS (
            SELECT 1 FROM users u
            WHERE u.user_id = pe.user_id
            AND u.role = 1
            )
        </if>
    </select>

    <!-- 기간별 DAU -->
    <select id="selectDAURange" parameterType="map" resultType="map">
        WITH d AS (
        SELECT gs::date AS day
        FROM generate_series(#{startDate}::date, #{endDate}::date, INTERVAL '1 day') AS gs
        )
        SELECT d.day, COALESCE(COUNT(DISTINCT pe.user_id), 0) AS count
        FROM d
        LEFT JOIN page_events pe
        ON (timezone('Asia/Seoul', pe.ts))::date = d.day
        AND pe.user_id IS NOT NULL
        <if test="excludeInternal">
            AND EXISTS (
            SELECT 1 FROM users u
            WHERE u.user_id = pe.user_id
            AND u.role = 1
            )
        </if>
        GROUP BY d.day
        ORDER BY d.day
    </select>

    <!-- 오늘/어제 DAU 비교 -->
    <select id="selectTodayYesterdayDAU" parameterType="map" resultType="map">
        SELECT
        (SELECT COUNT(DISTINCT pe.user_id)
        FROM page_events pe
        WHERE pe.user_id IS NOT NULL
        AND (timezone('Asia/Seoul', pe.ts))::date = CURRENT_DATE
        <if test="excludeInternal">
            AND EXISTS (SELECT 1 FROM users u WHERE u.user_id = pe.user_id AND u.role = 1)
        </if>
        ) AS today_dau,
        (SELECT COUNT(DISTINCT pe.user_id)
        FROM page_events pe
        WHERE pe.user_id IS NOT NULL
        AND (timezone('Asia/Seoul', pe.ts))::date = CURRENT_DATE - INTERVAL '1 day'
        <if test="excludeInternal">
            AND EXISTS (SELECT 1 FROM users u WHERE u.user_id = pe.user_id AND u.role = 1)
        </if>
        ) AS yesterday_dau
    </select>

    <!-- 오늘 가입자수 -->
    <select id="selectTodaySignups" resultType="long">
        SELECT COUNT(*) AS signups
        FROM users
        WHERE (timezone('Asia/Seoul', created_at))::date
                  = (now() AT TIME ZONE 'Asia/Seoul')::date
    </select>

    <!-- 기간별 가입자수 -->
    <select id="selectSignupRange" parameterType="map" resultType="map">
        WITH d AS (
            SELECT gs::date AS day
            FROM generate_series(#{startDate}::date, #{endDate}::date, interval '1 day') gs
        )
        SELECT
            d.day,
            COALESCE(COUNT(u.user_id), 0) AS count
        FROM d
                 LEFT JOIN users u
                           ON (timezone('Asia/Seoul', u.created_at))::date = d.day
        GROUP BY d.day
        ORDER BY d.day
    </select>

    <!-- 최근 로그인 사용자 목록 (KST 기준, 최근순) -->
    <select id="selectRecentLogins" parameterType="map" resultType="map">
        SELECT user_id as id,username, last_login
        FROM users
        WHERE last_login IS NOT NULL and role = 1
        <if test="sinceHours != null">
            AND (timezone('Asia/Seoul', last_login)) >= (now() AT TIME ZONE 'Asia/Seoul') - (#{sinceHours} || ' hours')::interval
        </if>
        ORDER BY last_login DESC
        LIMIT #{limit}
    </select>

    <!-- 전체 회원수 -->
    <select id="selectActiveUserCount" resultType="long">
        SELECT COUNT(*)
        FROM users
        WHERE role = 1
    </select>

</mapper>
